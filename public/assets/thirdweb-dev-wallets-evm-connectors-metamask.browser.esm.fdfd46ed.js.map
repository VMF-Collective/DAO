{"version":3,"file":"thirdweb-dev-wallets-evm-connectors-metamask.browser.esm.fdfd46ed.js","sources":["../../node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js","../../node_modules/@thirdweb-dev/wallets/evm/connectors/metamask/dist/thirdweb-dev-wallets-evm-connectors-metamask.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-60b19604.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError, C as ChainNotConfiguredError, A as AddChainError, S as SwitchChainError } from '../../../../dist/errors-105ad187.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nfunction getInjectedName(ethereum) {\n  if (!ethereum) {\n    return \"Injected\";\n  }\n  const getName = provider => {\n    if (provider.isAvalanche) {\n      return \"Core Wallet\";\n    }\n    if (provider.isBitKeep) {\n      return \"BitKeep\";\n    }\n    if (provider.isBraveWallet) {\n      return \"Brave Wallet\";\n    }\n    if (provider.isCoinbaseWallet) {\n      return \"Coinbase Wallet\";\n    }\n    if (provider.isExodus) {\n      return \"Exodus\";\n    }\n    if (provider.isFrame) {\n      return \"Frame\";\n    }\n    if (provider.isKuCoinWallet) {\n      return \"KuCoin Wallet\";\n    }\n    if (provider.isMathWallet) {\n      return \"MathWallet\";\n    }\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {\n      return \"1inch Wallet\";\n    }\n    if (provider.isOpera) {\n      return \"Opera\";\n    }\n    if (provider.isPortal) {\n      return \"Ripio Portal\";\n    }\n    if (provider.isTally) {\n      return \"Tally\";\n    }\n    if (provider.isTokenPocket) {\n      return \"TokenPocket\";\n    }\n    if (provider.isTokenary) {\n      return \"Tokenary\";\n    }\n    if (provider.isTrust || provider.isTrustWallet) {\n      return \"Trust Wallet\";\n    }\n    if (provider.isMetaMask) {\n      return \"MetaMask\";\n    }\n  };\n\n  // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n  if (ethereum.providers?.length) {\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length) {\n      return names;\n    }\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\n\nvar _provider = /*#__PURE__*/new WeakMap();\nclass InjectedConnector extends WagmiConnector {\n  /**\n   * Name of the injected connector\n   */\n\n  /**\n   * Whether the connector is ready to be used\n   *\n   * `true` if the injected provider is found\n   */\n\n  constructor(arg) {\n    const defaultOptions = {\n      shimDisconnect: true,\n      getProvider: () => {\n        if (assertWindowEthereum(globalThis.window)) {\n          return globalThis.window.ethereum;\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options\n    });\n    _defineProperty(this, \"id\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"ready\", void 0);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"connectorStorage\", void 0);\n    _defineProperty(this, \"shimDisconnectKey\", \"injected.shimDisconnect\");\n    /**\n     * handles the `accountsChanged` event from the provider\n     * * emits `change` event if connected to a different account\n     * * emits `disconnect` event if no accounts available\n     */\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n    /**\n     * handles the `chainChanged` event from the provider\n     * * emits `change` event if connected to a different chain\n     */\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    /**\n     * handles the `disconnect` event from the provider\n     * * emits `disconnect` event\n     */\n    _defineProperty(this, \"onDisconnect\", async error => {\n      // We need this as MetaMask can emit the \"disconnect\" event upon switching chains.\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error.code === 1013) {\n        const provider = await this.getProvider();\n        if (provider) {\n          const isAuthorized = await this.getAccount();\n          if (isAuthorized) {\n            return;\n          }\n        }\n      }\n      this.emit(\"disconnect\");\n\n      // Remove `shimDisconnect` => it signals that wallet is disconnected\n      if (this.options.shimDisconnect) {\n        await this.connectorStorage.removeItem(this.shimDisconnectKey);\n      }\n    });\n    const _provider2 = options.getProvider();\n\n    // set the name of the connector\n    if (typeof options.name === \"string\") {\n      // if name is given, use that\n      this.name = options.name;\n    } else if (_provider2) {\n      // if injected provider is detected, get name from it\n      const detectedName = getInjectedName(_provider2);\n      if (options.name) {\n        this.name = options.name(detectedName);\n      } else {\n        if (typeof detectedName === \"string\") {\n          this.name = detectedName;\n        } else {\n          this.name = detectedName[0];\n        }\n      }\n    } else {\n      // else default to \"Injected\"\n      this.name = \"Injected\";\n    }\n    this.id = \"injected\";\n    this.ready = !!_provider2;\n    this.connectorStorage = arg.connectorStorage;\n  }\n\n  /**\n   * * Connect to the injected provider\n   * * switch to the given chain if `chainId` is specified as an argument\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // request account addresses from injected provider\n      const accountAddresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n\n      // get the first account address\n      const firstAccountAddress = utils.getAddress(accountAddresses[0]);\n\n      // Switch to given chain if a chainId is specified\n      let connectedChainId = await this.getChainId();\n      // Check if currently connected chain is unsupported\n      // chainId is considered unsupported if chainId is not in the list of this.chains array\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is specified and it is not the same as the currently connected chain\n      if (options.chainId && connectedChainId !== options.chainId) {\n        // switch to the given chain\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate connectedChainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id: ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options.shimDisconnect) {\n        // add the shim shimDisconnectKey => it signals that wallet is connected\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        account: firstAccountAddress,\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * disconnect from the injected provider\n   */\n  async disconnect() {\n    // perform cleanup\n    const provider = await this.getProvider();\n    if (!provider?.removeListener) {\n      return;\n    }\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n\n    // if shimDisconnect is enabled\n    if (this.options.shimDisconnect) {\n      // Remove the shimDisconnectKey => it signals that wallet is disconnected\n      await this.connectorStorage.removeItem(this.shimDisconnectKey);\n    }\n  }\n\n  /**\n   * @returns The first account address from the injected provider\n   */\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n\n    // return checksum address\n    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress\n    return utils.getAddress(accounts[0]);\n  }\n\n  /**\n   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`\n   */\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n\n  /**\n   * get the injected provider\n   */\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider) {\n      _classPrivateFieldSet(this, _provider, provider);\n      // setting listeners\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  /**\n   * get a `signer` for given `chainId`\n   */\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n\n    // ethers.providers.Web3Provider\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  /**\n   *\n   * @returns `true` if the connector is connected and address is available, else `false`\n   */\n  async isAuthorized() {\n    try {\n      // `false` if connector is disconnected\n      if (this.options.shimDisconnect &&\n      // If shim does not exist in storage, wallet is disconnected\n      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        return false;\n      }\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      // `false` if no account address available, else `true`\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      // `false` if any error thrown\n      return false;\n    }\n  }\n\n  /**\n   * switch to given chain\n   */\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const chainIdHex = utils.hexValue(chainId);\n    try {\n      // request provider to switch to given chainIdHex\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (chain) {\n        return chain;\n      }\n      return {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        slug: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        chain: \"\",\n        shortName: \"\",\n        testnet: true\n      };\n    } catch (error) {\n      // if could not switch to given chainIdHex\n\n      // if tried to connect to a chain that is not configured\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError({\n          chainId,\n          connectorId: this.id\n        });\n      }\n\n      // if chain is not added to provider\n      if (error.code === 4902 ||\n      // Unwrapping for MetaMask Mobile\n      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n      error?.data?.originalError?.code === 4902) {\n        try {\n          // request provider to add chain\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: chainIdHex,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: chain.rpc,\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          // if user rejects request to add chain\n          if (this.isUserRejectedRequestError(addError)) {\n            throw new UserRejectedRequestError(error);\n          }\n\n          // else other error\n          throw new AddChainError();\n        }\n      }\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n}\n\nexport { InjectedConnector };\n","import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-105ad187.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-1ea97411.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport '../../../../dist/WagmiConnector-60b19604.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nimport '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\nclass MetaMaskConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider() {\n        function getReady(ethereum) {\n          const isMetaMask = !!ethereum?.isMetaMask;\n          if (!isMetaMask) {\n            return;\n          }\n          // Brave tries to make itself look like MetaMask\n          // Could also try RPC `web3_clientVersion` if following is unreliable\n          if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) {\n            return;\n          }\n          if (ethereum.isAvalanche) {\n            return;\n          }\n          if (ethereum.isKuCoinWallet) {\n            return;\n          }\n          if (ethereum.isPortal) {\n            return;\n          }\n          if (ethereum.isTokenPocket) {\n            return;\n          }\n          if (ethereum.isTokenary) {\n            return;\n          }\n          return ethereum;\n        }\n        if (assertWindowEthereum(globalThis.window)) {\n          if (globalThis.window.ethereum?.providers) {\n            return globalThis.window.ethereum.providers.find(getReady);\n          }\n          return getReady(globalThis.window.ethereum);\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n    _defineProperty(this, \"id\", walletIds.metamask);\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  /**\n   * Connect to injected MetaMask provider\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n      let account = null;\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all MetaMask injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      }\n\n      // if account is not already set, request accounts and use the first account\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      }\n\n      // get currently connected chainId\n      let connectedChainId = await this.getChainId();\n      // check if connected chain is unsupported\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate the chainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n  async switchAccount() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_requestPermissions\",\n      params: [{\n        eth_accounts: {}\n      }]\n    });\n  }\n}\n\nexport { MetaMaskConnector };\n"],"names":["getInjectedName","ethereum","getName","provider","_a","nameSet","unknownCount","name","names","_b","_c","_provider","InjectedConnector","WagmiConnector","arg","options","assertWindowEthereum","_defineProperty","_classPrivateFieldInitSpec","accounts","utils.getAddress","chainId","id","normalizeChainId","unsupported","error","_provider2","detectedName","ConnectorNotFoundError","accountAddresses","firstAccountAddress","connectedChainId","isUnsupported","e","connectionInfo","UserRejectedRequestError","ResourceUnavailableError","_classPrivateFieldSet","_classPrivateFieldGet","account","providers.Web3Provider","chainIdHex","utils.hexValue","chain","_chain","ChainNotConfiguredError","addError","AddChainError","SwitchChainError","_UNSTABLE_shimOnConnectSelectAccount","MetaMaskConnector","getReady","walletIds"],"mappings":"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"}